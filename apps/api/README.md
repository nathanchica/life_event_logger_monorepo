# life_event_logger_api

## Overview

GraphQL API for Life Event Logger app

Built with:

- **GraphQL Yoga** server
- **Prisma ORM** for MongoDB Atlas database
- **Vercel** serverless
- **TypeScript**
- **graphql-codegen** for generating GQL types based on schema
- **google-auth-library** and **jsonwebtoken** for user authentication and session management
- **Sqids** for encoding and decoding IDs
- **Husky**, **Prettier**, **ESLint** for maintaining code standards
- **graphql-scalars** for custom scalar types
- **zod** for form validation and env var validation
- **npm** for dependency management
- **Vitest** for testing framework

## Table of Contents

1. [Development Setup](#development-setup)
2. [Architecture](#architecture)
3. [Cron Jobs](#cron-jobs)
4. [Authentication Flow](#authentication-flow)
5. [GraphQL Security Directives](#graphql-security-directives)
6. [Error Handling Patterns](#error-handling-patterns)
7. [Testing](#testing)
8. [ES Module Import Extensions](#es-module-import-extensions)

## Development Setup

### Prerequisites

- Node.js (v18 or higher)
- npm
- MongoDB Atlas account (for database)
- Google OAuth credentials (for authentication)

### Setup

1. Install dependencies:

```bash
npm install
```

2. Set up environment variables:
   Create a `.env` file in the root directory with the following variables:

```env
# MongoDB Atlas connection string
DATABASE_URL="mongodb+srv://<username>:<password>@<cluster>.mongodb.net/<database>?retryWrites=true&w=majority"

# JWT secret for token generation
JWT_SECRET="your-secret-key"

# Google OAuth Client ID
GOOGLE_CLIENT_ID="your-google-client-id"

# Node environment
NODE_ENV="development"

# Token expiration settings
ACCESS_TOKEN_EXPIRES_IN_SECONDS=900  # 15 minutes
REFRESH_TOKEN_EXPIRES_IN_DAYS=30     # For backward compatibility

# Sliding window authentication
REFRESH_TOKEN_SLIDING_DAYS=7         # Activity extends by this many days
REFRESH_TOKEN_ABSOLUTE_MAX_DAYS=30   # Maximum session lifetime

See `.env.example` for other required variables.
```

3. Generate Prisma client (This is needed to generate Prisma models and types from the schema):

```bash
npm run prisma:generate
```

### Running the Development Server

1. Start the development server:

```bash
npm run dev
```

The GraphQL server will start at http://localhost:4000/api/graphql

2. Access GraphQL playground:
   Navigate to http://localhost:4000/api/graphql in your browser to access the GraphQL playground for testing queries and mutations.

### Running Tests

```bash
# Run all tests with coverage
npm test

# Run tests in watch mode
npm run test:watch

# Run specific test file
npm test eventLabel.test.ts
```

### Database Management

```bash
# Push schema changes to database
npm run prisma:push

# Open Prisma Studio (database GUI)
npm run prisma:studio

# Format Prisma schema
npm run prisma:format
```

### Code Quality

```bash
# Run linting
npm run lint

# Run type checking
npm run type-check

# Format code with Prettier
npm run format
```

### GraphQL Schema Management

```bash
# Generate TypeScript types from GraphQL schema
npm run generate

# Watch for schema changes and regenerate types
npm run generate:watch
```

## Architecture

```
src/
‚îú‚îÄ‚îÄ schema/
‚îÇ   ‚îú‚îÄ‚îÄ eventLabel/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts                    # Resolver implementation
|   ‚îÇ   ‚îú‚îÄ‚îÄ eventLabel.graphql          # Schema file
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __tests__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ eventLabel.test.ts      # Test file
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __mocks__/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ eventLabel.ts           # Mock data factories
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ root/                           # Schema root
‚îÇ   ‚îî‚îÄ‚îÄ index.ts                        # Schema merging (New resolvers and directives need to update this file)
|
‚îú‚îÄ‚îÄ cron/
‚îÇ   ‚îú‚îÄ‚îÄ daily-maintenance.ts            # Main cron orchestrator
‚îÇ   ‚îú‚îÄ‚îÄ tasks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ check-events.ts            # Event threshold monitoring
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cleanup-tokens.ts          # Expired token cleanup
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ send-discord.ts            # Discord notification summary
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îî‚îÄ‚îÄ discord-webhook.ts         # Discord webhook helper
‚îú‚îÄ‚îÄ directives/                         # GraphQL directives
‚îú‚îÄ‚îÄ auth/                               # OAuth and JWT handling
‚îú‚îÄ‚îÄ prisma/
|   ‚îú‚îÄ‚îÄ client.ts                       # Prisma client
‚îÇ   ‚îî‚îÄ‚îÄ __mocks__/
|        ‚îî‚îÄ‚îÄ client.ts                  # Mock Prisma Client
‚îú‚îÄ‚îÄ mocks/                              # GraphQL Yoga client and context mocks for testing
‚îú‚îÄ‚îÄ codegen/                            # GraphQL autogenerated types
‚îî‚îÄ‚îÄ context.ts                          # GraphQL context

api/
‚îú‚îÄ‚îÄ graphql.ts                          # Vercel serverless function
‚îî‚îÄ‚îÄ cron/
    ‚îî‚îÄ‚îÄ daily.ts                        # Daily cron job endpoint
```

## Cron Jobs

This API implements scheduled maintenance tasks using Vercel Cron Jobs for automated system maintenance and user notifications.

### Overview

The cron system runs daily maintenance tasks including:

- **Token Cleanup**: Removes expired refresh tokens older than 24 hours
- **Event Monitoring**: Checks for overdue events for a configured user based on user-defined thresholds
- **Discord Notifications**: Sends consolidated daily summaries via Discord webhooks

### Configuration

#### Vercel Cron Configuration

```json
// vercel.json
{
    "crons": [
        {
            "path": "/api/cron/daily",
            "schedule": "0 7 * * *" // Daily at 7 AM UTC / 12 AM PST
        }
    ]
}
```

#### Required Environment Variables

```env
# Security token for cron endpoint
CRON_SECRET="your-random-secret-here"

# Discord webhook for notifications
DISCORD_WEBHOOK_URL="https://discord.com/api/webhooks/..."

# User email for event monitoring
EVENT_ALERTS_USER_EMAIL="user@example.com"
```

### Daily Maintenance Tasks

#### 1. Token Cleanup (`cleanup-tokens.ts`)

- Deletes expired refresh tokens older than 24 hours
- Prevents database bloat from accumulated expired tokens
- Returns count of deleted tokens for reporting

#### 2. Event Threshold Monitoring (`check-events.ts`)

- Monitors loggable events for the configured user
- Checks events against their warning thresholds
- Identifies overdue events based on days since last logged
- Returns detailed information about overdue events

#### 3. Discord Summary (`send-discord.ts`)

- Sends a consolidated daily report to Discord
- Color-coded status indicators:
    - üü¢ Green: All systems normal
    - üü† Orange: Events overdue (warnings)
    - üî¥ Red: Errors occurred during maintenance
- Includes detailed breakdown of overdue events (up to 15)
- Shows maintenance statistics (tokens cleaned, events checked)

### Discord Message Format

The daily maintenance report includes:

- **Summary Statistics**: Tokens cleaned, events checked, overdue count
- **Overdue Event Details** (if any):
    - Event name and labels
    - Days since last logged
    - Threshold setting
    - Days overdue calculation
- **Error Reporting** (if any): Up to 5 error messages

### Security

The cron endpoint (`/api/cron/daily`) is protected by:

1. **Authorization header** verification with `CRON_SECRET`
2. **Vercel-only access** - requests from outside Vercel are rejected
3. **No sensitive data exposure** - all secrets in environment variables

### Monitoring

- View execution logs in Vercel Dashboard ‚Üí Functions ‚Üí Logs
- Discord webhook provides real-time notification of job completion
- Check for color-coded status in Discord messages
- Monitor error count and details in daily summaries

## Authentication Flow

This API uses Google OAuth for user authentication with JWT access tokens and refresh tokens for session management.

### Token Types

1. **Access Token**: Short-lived JWT (15 minutes) for API requests
2. **Refresh Token**: Long-lived token with sliding window expiration
    - Stored as httpOnly cookie for web clients
    - Extends by 7 days on each use (up to 30 days maximum)
    - Absolute maximum lifetime of 30 days

### Login Process

1. **Frontend**: User signs in with Google and obtains Google OAuth ID token
2. **Frontend**: Sends Google OAuth token to `googleOAuthLoginMutation`
3. **Backend**: Verifies Google OAuth token using Google's auth library
4. **Backend**: Creates or finds user in database
5. **Backend**: Generates:
    - JWT access token (15 minutes)
    - Refresh token with sliding window expiration
6. **Backend**: Sets refresh token as httpOnly cookie
7. **Backend**: Returns access token and user object to frontend
8. **Frontend**: Stores access token in memory for API requests

### Sliding Window Authentication

The refresh token implements a sliding window expiration mechanism:

- **Initial Duration**:
    - Without "Remember Me": 1 day
    - With "Remember Me": 7 days (pending implementation)
- **Extension on Use**: Each token refresh extends expiration by 7 days
- **Maximum Lifetime**: 30 days absolute maximum (never exceeds)
- **Inactivity Timeout**: Token expires after configured period of no use

### Token Refresh Process

1. **Frontend**: Access token expires or is about to expire
2. **Frontend**: Calls `refreshTokenMutation` (refresh token in cookie)
3. **Backend**: Validates refresh token
4. **Backend**: Extends sliding window expiration (up to absolute max)
5. **Backend**: Rotates refresh token for security
6. **Backend**: Returns new access token
7. **Frontend**: Updates stored access token

### Authenticated Requests

1. **Frontend**: Includes access token in `Authorization: Bearer <jwt>` header
2. **Backend**: Verifies JWT access token in GraphQL context
3. **Backend**: Loads user from database using `userId` from JWT payload
4. **Backend**: Provides `user` object to resolvers via GraphQL context

### Example Mutations

```graphql
# Login mutation (sets refresh token as httpOnly cookie)
mutation GoogleOAuthLogin($input: GoogleOAuthLoginMutationInput!) {
    googleOAuthLoginMutation(input: $input) {
        accessToken # Short-lived JWT for API requests
        user {
            id
            email
            name
        }
        errors {
            code
            message
        }
    }
}

# Refresh token mutation (uses refresh token from cookie)
mutation RefreshToken {
    refreshTokenMutation {
        accessToken # New access token
        errors {
            code
            message
        }
    }
}

# Logout mutation (clears refresh token cookie)
mutation Logout($input: LogoutMutationInput) {
    logoutMutation(input: $input) {
        success
        errors {
            code
            message
        }
    }
}
```

### Frontend Integration

The web app uses a TokenStorage service (`apps/web/src/apollo/tokenStorage.ts`) that:

- **Stores access tokens in memory only** (for security)
- **Automatically checks token expiration** with a 30-second buffer
- **Handles token refresh** using the refresh token cookie
- **Prevents race conditions** when multiple requests need refresh
- **Works with Apollo Client** for automatic authentication

Key methods:

- `setAccessToken(token, expiresInSeconds)` - Store access token with expiration
- `getValidAccessToken()` - Get current token or refresh if expired
- `clear()` - Clear stored tokens on logout

The refresh token (httpOnly cookie) automatically extends its expiration by 7 days on each use, up to a maximum of 30 days, keeping users logged in during active use.

## GraphQL Security Directives

This API uses custom GraphQL directives to handle authentication and authorization declaratively.

### Available Directives

#### `@requireAuth`

Requires user authentication. Used for operations that need a logged-in user.

```graphql
type Query {
    loggedInUser: User @requireAuth
}

type Mutation {
    createLoggableEvent(input: CreateLoggableEventMutationInput!): CreateLoggableEventMutationPayload! @requireAuth
}
```

#### `@requireOwner(resource: String!)`

Requires user authentication AND ownership of the specified resource. Used for operations that modify user-owned data.

```graphql
type Mutation {
    updateLoggableEvent(input: UpdateLoggableEventMutationInput!): UpdateLoggableEventMutationPayload!
        @requireOwner(resource: "loggableEvent")
    deleteEventLabel(input: DeleteEventLabelMutationInput!): DeleteEventLabelMutationPayload!
        @requireOwner(resource: "eventLabel")
}
```

### Supported Resources

- `loggableEvent` - Validates ownership of LoggableEvent entities
- `eventLabel` - Validates ownership of EventLabel entities

### Error Handling

Directives return standardized GraphQL errors:

- **`UNAUTHORIZED`**: User not authenticated
- **`FORBIDDEN`**: User lacks permission for the resource
- **`NOT_FOUND`**: Requested resource doesn't exist
- **`VALIDATION_ERROR`**: Invalid input or missing resource ID

## Error Handling Patterns

This API uses three distinct patterns for error handling, each suited for different types of errors:

### 1. GraphQL Errors (Exceptions)

These are thrown and appear in the `errors` array of the GraphQL response. Used for:

- **Authentication failures** - When user is not logged in
- **Authorization failures** - When user lacks permission (e.g., trying to access another user's resources)
- **Resource not found** - When attempting operations on non-existent entities
- **Invalid cross-resource references** - When referencing labels/resources that don't belong to the user

**Example Response:**

```json
{
    "data": null,
    "errors": [
        {
            "message": "Some labels do not exist or do not belong to you",
            "extensions": {
                "code": "FORBIDDEN"
            }
        }
    ]
}
```

**Implementation:**

```typescript
// Thrown from resolvers or directives
throw new GraphQLError('Some labels do not exist or do not belong to you', {
    extensions: { code: 'FORBIDDEN' }
});
```

**Note:** GraphQL errors created with `GraphQLError` are not masked and their messages are sent to clients as-is.

### 2. API Errors (Result Pattern)

These are returned as part of the mutation payload in an `errors` field. Used for:

- **Validation errors** - Invalid input data (e.g., name too long, negative numbers)
- **Business logic errors** - Errors that users can fix by changing their input
- **Partial success scenarios** - When some information can still be returned

**Example Response:**

```json
{
    "data": {
        "createLoggableEvent": {
            "loggableEvent": null,
            "errors": [
                {
                    "code": "VALIDATION_ERROR",
                    "field": "name",
                    "message": "Name must be under 25 characters"
                }
            ]
        }
    }
}
```

**Implementation:**

```typescript
// Returned in mutation payloads
return {
    loggableEvent: null,
    errors: [
        {
            code: 'VALIDATION_ERROR',
            field: 'name',
            message: 'Name must be under 25 characters'
        }
    ]
};
```

### 3. Internal Errors (Masked Exceptions)

These are system/unexpected errors that get automatically masked by GraphQL Yoga for security. Used for:

- **Database failures** - Connection errors, query timeouts
- **Network issues** - External service failures
- **Unexpected errors** - Programming errors, null pointer exceptions
- **Any unhandled errors** - Errors not explicitly caught

**Example Response:**

```json
{
    "data": null,
    "errors": [
        {
            "message": "Unexpected error.",
            "extensions": {
                "code": "INTERNAL_SERVER_ERROR"
            },
            "path": ["updateEventLabel"]
        }
    ]
}
```

**Implementation:**

```typescript
// Any thrown Error (not GraphQLError) gets masked
throw new Error('Database connection failed: timeout after 30s');
// Client sees: "Unexpected error."

// In catch blocks for system errors
catch (error) {
    // Log full error server-side for debugging
    console.error('Database error:', error);
    // Throw generic error that gets masked
    throw new Error('Internal server error');
}
```

**Error Masking:** GraphQL Yoga automatically masks error messages from regular `Error` objects to prevent leaking sensitive information. The original error is logged server-side, but clients only see "Unexpected error." This is a security best practice recommended by [GraphQL Yoga documentation](https://the-guild.dev/graphql/yoga-server/docs/features/error-masking).

### When to Use Each Pattern

| Error Type          | Pattern        | Reason                                         |
| ------------------- | -------------- | ---------------------------------------------- |
| Auth failures       | GraphQL Error  | Security violations should interrupt execution |
| Invalid labelIds    | GraphQL Error  | Cross-resource authorization failure           |
| Name too long       | API Error      | User can fix by changing input                 |
| Invalid date format | API Error      | Validation that user can correct               |
| Database connection | Internal Error | System error - details should be hidden        |
| Null reference      | Internal Error | Programming error - mask for security          |

## Testing

This project uses Vitest instead of Jest as its testing framework since it natively supports ESM, is much faster, and
has minimal configuration needed compared to Jest.

See these blogs about Vitest vs Jest:

- https://www.prisma.io/blog/testing-series-1-8eRB5p0Y8o#why-vitest
- https://www.wisp.blog/blog/vitest-vs-jest-which-should-i-use-for-my-nextjs-app

\
As of 2025-08-26, tests coverage is 100%

```bash
 Test Files  13 passed (13)
      Tests  222 passed (222)
   Start at  04:43:45
   Duration  1.31s (transform 761ms, setup 458ms, collect 5.11s, tests 462ms, environment 2ms, prepare 1.22s)

 % Coverage report from v8
--------------------------|---------|----------|---------|---------|-------------------
File                      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
--------------------------|---------|----------|---------|---------|-------------------
All files                 |     100 |      100 |     100 |     100 |
 src                      |     100 |      100 |     100 |     100 |
  context.ts              |     100 |      100 |     100 |     100 |
 src/auth                 |     100 |      100 |     100 |     100 |
  token.ts                |     100 |      100 |     100 |     100 |
 src/config               |     100 |      100 |     100 |     100 |
  env.ts                  |     100 |      100 |     100 |     100 |
 src/cron                 |     100 |      100 |     100 |     100 |
  daily-maintenance.ts    |     100 |      100 |     100 |     100 |
 src/cron/tasks           |     100 |      100 |     100 |     100 |
  check-events.ts         |     100 |      100 |     100 |     100 |
  cleanup-tokens.ts       |     100 |      100 |     100 |     100 |
  send-discord.ts         |     100 |      100 |     100 |     100 |
 src/cron/utils           |     100 |      100 |     100 |     100 |
  discord-webhook.ts      |     100 |      100 |     100 |     100 |
 src/directives           |     100 |      100 |     100 |     100 |
  auth.ts                 |     100 |      100 |     100 |     100 |
 src/mocks                |     100 |      100 |     100 |     100 |
  client.ts               |     100 |      100 |     100 |     100 |
  context.ts              |     100 |      100 |     100 |     100 |
 src/schema               |     100 |      100 |     100 |     100 |
  index.ts                |     100 |      100 |     100 |     100 |
 src/schema/eventLabel    |     100 |      100 |     100 |     100 |
  index.ts                |     100 |      100 |     100 |     100 |
 src/schema/loggableEvent |     100 |      100 |     100 |     100 |
  index.ts                |     100 |      100 |     100 |     100 |
 src/schema/user          |     100 |      100 |     100 |     100 |
  index.ts                |     100 |      100 |     100 |     100 |
 src/utils                |     100 |      100 |     100 |     100 |
  encoder.ts              |     100 |      100 |     100 |     100 |
  error.ts                |     100 |      100 |     100 |     100 |
  plugins.ts              |     100 |      100 |     100 |     100 |
  validation.ts           |     100 |      100 |     100 |     100 |
--------------------------|---------|----------|---------|---------|-------------------
```

## ES Module Import Extensions

This project uses ES modules with `"type": "module"` in package.json. As a result, **all relative imports must include the `.js` file extension**, even when importing from `.ts` files.

See this [Reddit discussion](https://www.reddit.com/r/typescript/comments/1b87o96/esm_on_nodejs_file_extension_mandatory/)

### Why File Extensions Are Required

Node.js ES modules require explicit file extensions for several reasons:

1. **Official Node.js Standard** - [Node.js ES Modules documentation](https://nodejs.org/api/esm.html#mandatory-file-extensions) states: "A file extension must be provided when using the `import` keyword to resolve relative or absolute specifiers."

2. **Web Compatibility** - Browsers require exact file paths for ES module imports

3. **Performance** - No file system lookups for extension inference

4. **Clarity** - Makes imports explicit and unambiguous

### Examples in This Codebase

```typescript
// ‚úÖ Correct - includes .js extension
import { env } from '../config/env.js';
import { createContext } from '../context.js';
import schema from '../schema/index.js';

// ‚ùå Incorrect - will cause runtime errors
import { env } from '../config/env';
import { createContext } from '../context';
import schema from '../schema';
```

### Why `.js` and Not `.ts`?

When TypeScript compiles to JavaScript, the imports reference the compiled `.js` files. The `.js` extension in the import statement tells Node.js to look for the compiled JavaScript file at runtime.
